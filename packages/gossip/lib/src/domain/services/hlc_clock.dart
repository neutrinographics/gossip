import 'dart:math';
import '../value_objects/hlc.dart';
import 'time_source.dart';

/// Service for generating hybrid logical clock timestamps.
///
/// [HlcClock] maintains state to ensure all generated timestamps are
/// strictly monotonically increasing, even when:
/// - Physical time doesn't advance between events
/// - Physical time moves backwards (NTP corrections)
/// - Receiving timestamps from peers with faster clocks
///
/// The clock combines physical wall-clock time with a logical counter to
/// create timestamps that are both causally consistent and human-readable.
///
/// ## Monotonicity Guarantee
/// Every call to [now] or [receive] returns a timestamp strictly greater
/// than any previously returned timestamp. This holds even if:
/// - System clock doesn't advance
/// - System clock goes backwards
/// - Remote timestamps are in the future
///
/// ## Threading
/// This class is NOT thread-safe and must only be accessed from a single
/// Dart isolate. The library ensures this by keeping HlcClock internal to
/// the Coordinator, which runs in a single isolate.
///
/// ## Overflow Handling
/// The logical counter is limited to 16 bits (0-65535). When incrementing
/// would exceed this limit, the clock advances physicalMs by 1 and resets
/// the logical counter to 0. This ensures monotonicity is preserved while
/// keeping timestamps bounded to 64 bits total.
class HlcClock {
  final TimeSource _timeSource;
  int _lastPhysicalMs = 0;
  int _logicalCounter = 0;

  /// Creates an [HlcClock] using the given time source.
  HlcClock(this._timeSource);

  /// Generates a new timestamp for a local event.
  ///
  /// Combines current physical time with the logical counter to create
  /// a timestamp that is strictly greater than any previously generated
  /// timestamp.
  ///
  /// Algorithm:
  /// 1. If physical time advanced: use new time, reset counter to 0
  /// 2. If physical time same/backwards: increment counter
  /// 3. If counter overflows: advance physical by 1ms, reset counter
  ///
  /// Use when: Creating new log entries on this node.
  Hlc now() {
    final physical = _timeSource.nowMillis();
    if (physical > _lastPhysicalMs) {
      _lastPhysicalMs = physical;
      _logicalCounter = 0;
    } else {
      _logicalCounter++;
      if (_logicalCounter > 65535) {
        _lastPhysicalMs++;
        _logicalCounter = 0;
      }
    }
    return Hlc(_lastPhysicalMs, _logicalCounter);
  }

  /// Updates clock state when receiving a timestamp from a remote peer.
  ///
  /// Merges the remote timestamp with local state to ensure the returned
  /// timestamp is strictly greater than both:
  /// - Any previously generated local timestamp
  /// - The received remote timestamp
  ///
  /// This maintains causal consistency across the distributed system by
  /// ensuring happened-before relationships are preserved.
  ///
  /// Algorithm:
  /// 1. Take max of (current physical, last physical, remote physical)
  /// 2. Increment logical counter based on which time dominates
  /// 3. Handle counter overflow if needed
  ///
  /// Use when: Receiving messages from peers (to update local causality).
  Hlc receive(Hlc remote) {
    final physical = _timeSource.nowMillis();
    final maxPhysical = max(physical, max(_lastPhysicalMs, remote.physicalMs));

    if (maxPhysical == _lastPhysicalMs && maxPhysical == remote.physicalMs) {
      _logicalCounter = max(_logicalCounter, remote.logical) + 1;
    } else if (maxPhysical == _lastPhysicalMs) {
      _logicalCounter++;
    } else if (maxPhysical == remote.physicalMs) {
      _logicalCounter = remote.logical + 1;
    } else {
      _logicalCounter = 0;
    }
    _lastPhysicalMs = maxPhysical;

    if (_logicalCounter > 65535) {
      _lastPhysicalMs++;
      _logicalCounter = 0;
    }

    return Hlc(_lastPhysicalMs, _logicalCounter);
  }

  /// Returns the current clock state without advancing it.
  ///
  /// This represents the most recent timestamp generated or received.
  /// Does not modify internal state.
  ///
  /// Use when: Querying clock state without generating a new timestamp.
  Hlc get current => Hlc(_lastPhysicalMs, _logicalCounter);

  /// Restores the clock to a previous state.
  ///
  /// Sets internal state to match the given timestamp. Used when loading
  /// persisted clock state after application restart to ensure monotonicity
  /// is preserved across restarts.
  ///
  /// Warning: Only restore from timestamps previously generated by this
  /// node. Restoring arbitrary timestamps may violate monotonicity.
  ///
  /// Use when: Initializing clock from persisted state on startup.
  void restore(Hlc state) {
    _lastPhysicalMs = state.physicalMs;
    _logicalCounter = state.logical;
  }
}
